#%% 18.1.1 - Количество строк в файле

"""На вход программе подается строка текста с именем текстового файла. Напишите программу для вывода на экран количества строк данного файла.

Формат входных данных
На вход программе подается строка текста, содержащая имя существующего текстового файла.

Формат выходных данных
Программа должна вывести количество строк файла.

Примечание. Считайте, что исполняемая программа и указанный файл находятся в одной папке."""
with open(input(), 'r', encoding='utf-8') as f:
    print(len(f.readlines()))


#%% 18.1.2 - Суммарная стоимость

"""Вам доступен текстовый файл ledger.txt с данными о продажах фирмы за месяц. На каждой строке файла указано, сколько клиент заплатил за товар, в долларах (целое число):

$47
$100
$60
$12
$8
...
Напишите программу для подсчета суммарной месячной выручки фирмы. 

Формат входных данных
На вход программе ничего не подается.

Формат выходных данных
Программа должна вывести выручку фирмы (сумму всех чисел из файла) в соответствии с примером ниже.

Примечание 1. Считайте, что исполняемая программа и указанный файл находятся в одной папке."""
file = r'/Users/zwar/Downloads/ledger.txt'
# file = 'ledger.txt'
with open(file, 'r', encoding='utf-8') as f:
    print('$', sum(map(lambda x: int(x[1:-1]) if x[-1] == '\n' else int(x[1:]), f.readlines())), sep ='')


#%% 18.1.3 - Goooood students

"""Вам доступен текстовый файл grades.txt, содержащий оценки студента за три теста в каждом из триместров. Строки файла имеют вид: фамилия оценка_1 оценка_2 оценка_3.

Напишите программу для подсчета количества студентов, сдавших все три теста. Тест считается сданным, если количество баллов по нему не меньше 65.

Формат входных данных
На вход программе ничего не подается.

Формат выходных данных
Программа должна вывести количество студентов, сдавших все три теста.

Примечание 1. Считайте, что исполняемая программа и указанный файл находятся в одной папке."""
# 18.1.3 v1
file = r'/Users/zwar/Downloads/grades.txt'
# file = 'grades.txt'
with open(file, 'r', encoding='utf-8') as f:
    count = 0
    for student in f:
        name, t1, t2, t3 = student.strip().split()
        if int(t1) >= 65 and int(t2)>= 65 and int(t3)>= 65:
            count += 1
print(count)

#%% 18.1.3 v2
file = r'/Users/zwar/Downloads/grades.txt'
# file = 'grades.txt'
with open(file, 'r', encoding='utf-8') as f:
#    print(sum(1 for i in f.readlines()))
   print(sum(1 for i in f.readlines() if all([int(j)>=65 for j in i.split()[1:]])))

#%% 18.1.3 v3 - красивое решение с перебором индекса в lambda. жаль, сам не додумался до такого.
file = r'/Users/zwar/Downloads/grades.txt'
# file = 'grades.txt'

with open(file, 'r', encoding='utf-8') as f:
    print(len(list(filter(lambda x: all(int(x[i]) >= 65 for i in (1, 2, 3)), (map(str.split, f))))))


#%% 18.1.4 - Самое длинное слово в файле

"""Вам доступен текстовый файл words.txt со словами, разделенными пробелом. Напишите программу, которая находит и выводит самые длинные слова этого файла, не меняя порядка их следования.

Формат входных данных
На вход программе ничего не подается.

Формат выходных данных
Программа должна вывести самые длинные слова файла words.txt, каждое с новой строки, не меняя их порядка следования.

Примечание 1. Считайте, что исполняемая программа и указанный файл находятся в одной папке.

Примечание 2. Словом считайте любую группу символов без пробелов, даже если она включает цифры или знаки препинания."""
# 18.1.4 v1 через подсчет длинны
file = r'/Users/zwar/Downloads/words.txt'
# file = 'words.txt'
with open(file, 'r', encoding='utf-8') as f:
    longest_len = 0
    answer = []
    for word in f.read().strip().split():
        word_len = len(word)
        if word_len > longest_len:
            longest_len = word_len
            answer = [word]
        elif word_len == longest_len:
            answer.append(word)
print(*answer, sep='\n')

#%% 18.1.4 v2 через словарь из длин слов
file = r'/Users/zwar/Downloads/words.txt'
# file = 'words.txt'
with open(file, 'r', encoding='utf-8') as f:
    answer = dict()
    for word in f.read().strip().split():
        answer.setdefault(len(word), []).append(word)

print(*answer[max(answer)], sep='\n')